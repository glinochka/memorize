Dockerfile Reference

Docker can build images automatically by reading the instructions from a Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. This page describes the commands you can use in a Dockerfile.

Overview

The Dockerfile supports the following instructions:

ADD: Add local or remote files and directories.

ARG: Use build-time variables.

CMD: Specify default commands.

COPY: Copy files and directories.

ENTRYPOINT: Specify default executable.

ENV: Set environment variables.

EXPOSE: Describe which ports your application is listening on.

FROM: Create a new build stage from a base image.

HEALTHCHECK: Check a container's health on startup.

LABEL: Add metadata to an image.

MAINTAINER: Specify the author of an image.

ONBUILD: Specify instructions for when the image is used in a build.

RUN: Execute build commands.

SHELL: Set the default shell of an image.

STOPSIGNAL: Specify the system call signal for exiting a container.

USER: Set user and group ID.

VOLUME: Create volume mounts.

WORKDIR: Change working directory.

Format

Here is the format of the Dockerfile:

Comment
INSTRUCTION arguments

The instruction is not case-sensitive. However, convention is for them to be UPPERCASE to distinguish them from arguments more easily.

Docker runs instructions in a Dockerfile in order. A Dockerfile must begin with a FROM instruction. This may be after parser directives, comments, and globally scoped ARGs. The FROM instruction specifies the base image from which you are building. FROM may only be preceded by one or more ARG instructions, which declare arguments that are used in FROM lines in the Dockerfile.

Comments

BuildKit treats lines that begin with # as a comment, unless the line is a valid parser directive. A # marker anywhere else in a line is treated as an argument. This allows statements like:

Comment
RUN echo 'we are running some # of cool things'

Comment lines are removed before the Dockerfile instructions are executed. The comment in the following example is removed before the shell executes the echo command.

RUN echo hello \

comment
world

The following example is equivalent:

RUN echo hello
world

Comments don't support line continuation characters.

Note on Whitespace

For backward compatibility, leading whitespace before comments (#) and instructions (such as RUN) are ignored, but discouraged. Leading whitespace is not preserved in these cases, and the following examples are therefore equivalent:

Copy
    # this is a comment-line
RUN echo hello
RUN echo world

this is a comment-line
RUN echo hello
RUN echo world

Whitespace in instruction arguments, however, isn't ignored. The following example prints hello world with leading whitespace as specified:

RUN echo "
hello
world"

Parser Directives

Parser directives are optional, and affect the way in which subsequent lines in a Dockerfile are handled. Parser directives don't add layers to the build, and don't show up as build steps. Parser directives are written as a special type of comment in the form # directive=value. A single directive may only be used once.

The following parser directives are supported:

syntax

escape

check (since Dockerfile v1.8.0)

Once a comment, empty line or builder instruction has been processed, BuildKit no longer looks for parser directives. Instead it treats anything formatted as a parser directive as a comment and doesn't attempt to validate if it might be a parser directive. Therefore, all parser directives must be at the top of a Dockerfile.

Invalid Parser Directives

Invalid due to line continuation:

direc \
tive=value

Invalid due to appearing twice:

directive=value1
directive=value2
FROM ImageName

Treated as a comment because it appears after a builder instruction:

FROM ImageName

directive=value
Treated as a comment because it appears after a comment that isn't a parser directive:

About my dockerfile
directive=value
FROM ImageName

syntax Directive

Use the syntax parser directive to declare the Dockerfile syntax version to use for the build. If unspecified, BuildKit uses a bundled version of the Dockerfile frontend. Declaring a syntax version lets you automatically use the latest Dockerfile version without having to upgrade BuildKit or Docker Engine.

Most users will want to set this parser directive to docker/dockerfile:1, which causes BuildKit to pull the latest stable version of the Dockerfile syntax before the build.

syntax=docker/dockerfile:1
escape Directive

escape=\
Or

escape=`
The escape directive sets the character used to escape characters in a Dockerfile. If not specified, the default escape character is .

The escape character is used both to escape characters in a line, and to escape a newline. This allows a Dockerfile instruction to span multiple lines. Note that regardless of whether the escape parser directive is included in a Dockerfile, escaping is not performed in a RUN command, except at the end of a line.

Setting the escape character to is especially useful on Windows, where \ is the directory path separator. is consistent with Windows PowerShell.

Example of escape Directive on Windows

Consider the following example which would fail in a non-obvious way on Windows. The second \ at the end of the second line would be interpreted as an escape for the newline, instead of a target of the escape from the first . Similarly, the \ at the end of the third line would, assuming it was actually handled as an instruction, cause it be treated as a line continuation. The result of this Dockerfile is that second and third lines are considered a single instruction:

FROM microsoft/nanoserver
COPY testfile.txt c:\
RUN dir c:\

Results in:

PS E:\myproject> docker build -t cmd .

Sending build context to Docker daemon 3.072 kB
Step 1/2 : FROM microsoft/nanoserver
---> 22738ff49c6d
Step 2/2 : COPY testfile.txt c:\RUN dir c:
GetFileAttributesEx c:RUN: The system cannot find the file specified.
PS E:\myproject>

Solution Using escape Directive

By adding the escape parser directive, the following Dockerfile succeeds as expected with the use of natural platform semantics for file paths on Windows:

escape=`
FROM microsoft/nanoserver
COPY testfile.txt c:
RUN dir c:\

Results in:

PS E:\myproject> docker build -t succeeds --no-cache=true .

Sending build context to Docker daemon 3.072 kB
Step 1/3 : FROM microsoft/nanoserver
---> 22738ff49c6d
Step 2/3 : COPY testfile.txt c:
---> 96655de338de
Step 3/3 : RUN dir c:
---> Running in a2c157f842f5
Volume in drive C has no label.
Volume Serial Number is 7E6D-E0F7

Directory of c:\

10/05/2016 05:04 PM 1,894 License.txt
10/05/2016 02:22 PM DIR Program Files
10/05/2016 02:14 PM DIR Program Files (x86)
10/28/2016 11:18 AM 62 testfile.txt
10/28/2016 11:20 AM DIR Users
10/28/2016 11:20 AM DIR Windows
2 File(s) 1,956 bytes
4 Dir(s) 21,259,096,064 bytes free
---> 01c7f3bef04f
Successfully built 01c7f3bef04f
PS E:\myproject>